:- use_module(library(clpfd)).
:- dynamic prof/2, section/3, courseTitle/2, day/3.
:- initialization(main).

%###################################################################################################################
/*This section of code reads in the Scheduler App generated class list and sets up the fact database*/
main :-
	write_ln("Please input your list of classes as generated by the scheduler app and click enter. "),
	read([First | Rest]),
	addClasses([First | Rest]),
	assert(maxCourseLoad(18)),
	assert(minCourseLoad(12)).

addClasses([]).
addClasses([First | Rest]):-
	addClass(First),
	addClasses(Rest).

addClass([Title, Section, Units, StartDate, EndDate, Profs, Times]):-
	addCourseTitle(Title),
	assert(section(Title, Section, 0)),
	addProfs(Profs), 
	assert(class([Title, Section, Units, StartDate, EndDate, Profs, Times], 0)).

addProfs([]).
%This avoids duplication of professors
addProfs([X | Rest]):-
	prof(X, _),
	addProfs(Rest).
addProfs([X | Rest]):-
	assert(prof(X, 0)),
	addProfs(Rest).

%avoids duplicate courseTitles
addCourseTitle(Title):-
	courseTitle(Title, _).
addCourseTitle(Title):-
	assert(courseTitle(Title, 0)).


%###################################################################################################################
/*This section of code allows the user to specify their preferences for their schedule.*/
rateProf(Name, Value):- 
	prof(Name, _),
	retract(prof(Name, _)),
	assert(prof(Name, Value)). 

rateClass(Title, Value):- 
	courseTitle(Title, _),
	retract(courseTitle(Title, _)),
	assert(courseTitle(Title, Value)).

rateSection(Title, Section, Value):- 
	section(Title, Section, _),
	retract(section(Title, Name, _)),
	assert(section(Title, Name, Value)).

rateDay(Day, Val):-
	retract(day(Day, N, _)),
	assert(day(Day, N, Val)).

setMaxCourseLoad(N):-
	retract(maxCourseLoad(_)),
	assert(maxCourseLoad(N)).

setMinCourseLoad(N):-
	retract(minCourseLoad(_)),
	assert(minCourseLoad(N)).



%###################################################################################################################
% Methods to computes the  total value a class would add to the user's schedule
classValues([]).
classValues([[C1, V1] | RC]):-
	classValue(C1, V1),
	classValues(RC).

classValue([Title, Section, Units, StartDate, EndDate, Profs, Times], _):-
	retract(class([Title, Section, Units, StartDate, EndDate, Profs, Times], _)),
	courseTitle(Title, A),
	section(Title, Section, B),
	sumProfValue(Profs, C),
	sumTimeValue(Times, D),
	Value is A + B + C + D,
	assert(class([Title, Section, Units, StartDate, EndDate, Profs, Times], Value)).

sumProfValue([], 0).
sumProfValue([Prof1 | RestProfs], Value):- 
	sumProfValue(RestProfs, VRest),
	prof(Prof1, V1),
	Value is V1 + VRest.

sumTimeValue([], 0).
sumTimeValue([[D1 | _] | RestT], Value):-
	sumTimeValue(RestT, VRest),
	day(_, D1, V1),
	Value is V1 + VRest.

%###################################################################################################################
/* This section of code, called by typing 'generateSchedule.' prints out the schedules generated for a user*/
numSchedulesToGenerate(Num):-
	findall([OriginalX, OriginalVa], class(OriginalX, OriginalVa), Classes),
	classValues(Classes),
	findall([X, Va], class(X, Va), AllCourses),
	findall([MySchedule, Value, Units], (validSchedule(AllCourses, MySchedule, Value, Units)), Schedules),
	sort(2, @>=, Schedules, Sorted),
	%Currently writing all generated, valid schedules. Will modify so you only write highest rated schedules.
	writeSchedules(Sorted, 0, Num).

validSchedule(AllCourses, MySchedule, Value, Units):-
	subseq(AllCourses, MySchedule, 0, Units),
	noRepeatClasses(MySchedule),
	noTimeConflicts(MySchedule),
	scheduleVal(MySchedule, 0, Value).

writeSchedules(_, Num, Num).
writeSchedules([], N, _):-
	write("There were only "),
	write(N),
	write_ln(" possible schedules.").
writeSchedules([ [H, Va, Units]| Rest], N, MaxPrintedSchedules):-
	N \= MaxPrintedSchedules,
	M is N +1,
	write("Schedule Number: "),
	write(M),
	write(" has "),
	write(Units),
	write(" and a preference value of "),
	write_ln(Va),
	writeSchedule(H),
	writeSchedules(Rest, M, MaxPrintedSchedules).

writeSchedule([]):-
	write_ln("").
writeSchedule([[[Title, Section | _], Value]| Rest]):-
	write(Title),
	write(" "),
	write(Section),
	write(" "),
	write_ln(Value),
	writeSchedule(Rest).

%###################################################################################################################

%returns all possible combinations sets of courses between the min and max number of units.
subseq([], [], N, N):-
	minCourseLoad(X),
	N >= X,
	maxCourseLoad(Y),
	Y >= N.
subseq([_ | RestCourses], MyClasses, N, U) :-
	subseq(RestCourses, MyClasses, N, U).
subseq([Class | RestCourses], [Class | RestMyClasses], N, U) :-
	maxCourseLoad(Y),
	N < Y,
	unitsSum(Class, N, M),
	subseq(RestCourses, RestMyClasses, M, U).

unitsSum([[_, _, Units | _], _], N, M):-
	M is Units + N.

%Checks that no class has been added multiple times to a schedule.
noRepeatClasses(ClassList):-
	classNameList(ClassList, NameList),
    is_set(NameList).

% Get the title of every course in a schedule
classNameList([], []).
classNameList([[[H|_]|_]|Rest], [H | RNames]):-
	classNameList(Rest, RNames).

%generates list of list of class times. and passes to classConflict
noTimeConflicts(MySchedule):-
	classStartAndEnd(MySchedule, [FirstClassTL | RestClassTL]),
	classConflict(FirstClassTL, RestClassTL).

%returns a list of all class times in a given possible schedule which can then be checked for conflicts.
classStartAndEnd([], []).
classStartAndEnd([[[_, _, _, SDate, EDate, _, Times], _] | Rest ], [[SDate, EDate, Times] | RTimes]):-
	classStartAndEnd(Rest, RTimes).

%gets every 2 classes' lists of times and passes them to singleClassConflict or dateConflict to check if they conflict.
classConflict(_, []).
classConflict([S1, E1, Class1], [[ S2, E2, Class2]| Rest]):-
	singleClassConflict(Class1, Class2),
	classConflict([S1, E1, Class1], Rest),
	classConflict([S2, E2, Class2], Rest), !.
classConflict([S1, E1, Class1], [[ S2, E2, Class2]| Rest]):-
	dateConflict(S1, E2),
	classConflict([S1, E1, Class1] , Rest),
	classConflict([S2, E2, Class2], Rest), !.
classConflict([S1, E1, Class1], [[S2, E2, Class2]| Rest]):-
	dateConflict(S2, E1),
	classConflict([S1, E1, Class1], Rest),
	classConflict([S2, E2, Class2], Rest).

%Checks if the end month of one class is the start month of another class. (They are opposite half semester classes.)
dateConflict([M1 | _], [M2 | _]):-
	M1 = M2.

%passes each time block for class 1 and all of class 2's time blocks to singleTimeSlot
singleClassConflict([], _).
singleClassConflict([C1T1 | RestC1], C2):-
	singleTimeSlot(C1T1, C2),
	singleClassConflict(RestC1, C2).

%passes each time block for class 2 along with a specific time block of class 1 to singleTimeSlot
singleTimeSlot(_, []).
singleTimeSlot(C1T1, [C2T1 | RestC2]):-
	singleTimeConflict(C1T1, C2T1),
	singleTimeSlot(C1T1, RestC2).


% Checks if 2 class times overlap
singleTimeConflict([D1 | _], [D2 | _]):-
	D1 \= D2.
singleTimeConflict([D1, S1, E1 | _], [D2, S2 | _]):-
	D1 = D2,
	S1 < S2, 
	E1 < S2.
singleTimeConflict([D1, S1 | _], [D2, S2, E2 | _]):-
	D1 = D2,
	S2< S1, 
	E2 < S1.

%Generates a singal schedules value
scheduleVal([], CurVal, CurVal).
scheduleVal([ [_, CVal] | MySchedule], CurVal, Value):-
	NValue is CVal + CurVal,
	scheduleVal(MySchedule, NValue, Value).

%###################################################################################################################
%Initial Assertions which may be modified by the user.

day('Monday',0,0).
day('Tuesday',1,0).
day('Wednesday',2,0).
day('Thursday',3,0).
day('Friday',4,0).
day('Saturday',5,0).
day('Sunday',6,0).

