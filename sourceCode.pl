% Run in terminal with the command: /usr/local/bin/swipl -f sourceCode.pl

:- use_module(library(clpfd)).
:- ensure_loaded(preferenceSetter).
:- ensure_loaded(database).
:- initialization(main).

%###################################################################################################################
/*This section of code reads in the Scheduler App generated class list and sets up the fact database*/
main :-
	write_ln("Please input your list of classes as generated by the scheduler app and click enter. "),
	read([First | Rest]),
	addClasses([First | Rest]),
	write_ln(''),
	write_ln("Please input the name of the file in which your program is written inside quotation marks and followed by a period. "),
	write_ln(''),
	read(FileName),
	write_ln("Please input the number of schedules you would like to generate followed by a period. "),
	read(Num),
	generateSchedules(FileName, Num).

%###################################################################################################################
/* This section of code, called by typing 'generateSchedule.' prints out the schedules generated for a user*/
generateSchedules(FileName, Num):-
	readInFile(FileName),
	findall([OriginalX, OriginalVa], class(OriginalX, OriginalVa), Classes),
	classValues(Classes),
	findall([X, Va], class(X, Va), AllCourses),
	findall([MySchedule, Value, Units], (validSchedule(AllCourses, MySchedule, Value, Units)), Schedules),
	sort(2, @>=, Schedules, Sorted),
	write_ln(""),
	writeSchedules(Sorted, 0, Num).

verifyMinMax(Min, Max):-
	write_ln(''),
	write_ln(Min),
	Max >= Min.
verifyMinMax(Min, Max):-
	write_ln(""),
	write("Error: Your minimum course load of "),
	write(Min),
	write(" must be less than or equal to your maximum course load of "),
	write_ln(Max).

validSchedule(AllCourses, MySchedule, Value, Units):-
	subseq(AllCourses, MySchedule, 0, Units),
	noRepeatClasses(MySchedule),
	noTimeConflicts(MySchedule),
	scheduleVal(MySchedule, 0, Value).

writeSchedules(_, Num, Num).
writeSchedules([], N, _):-
	write("There were only "),
	write(N),
	write_ln(" possible schedules.").
writeSchedules([ [H, Va, Units]| Rest], N, MaxPrintedSchedules):-
	N \= MaxPrintedSchedules,
	M is N +1,
	write("Schedule Number: "),
	write(M),
	write(" has "),
	write(Units),
	write(" units and a preference value of "),
	write_ln(Va),
	writeSchedule(H),
	writeSchedules(Rest, M, MaxPrintedSchedules).

writeSchedule([]):-
	write_ln("").
writeSchedule([[[Title, Section | _], Value]| Rest]):-
	write(Title),
	write(" "),
	write(Section),
	write(" "),
	write_ln(Value),
	writeSchedule(Rest).

%###################################################################################################################

%returns all possible combinations sets of courses between the min and max number of units.
subseq([], [], N, N):-
	minCourseLoad(X),
	N >= X,
	maxCourseLoad(Y),
	Y >= N.
subseq([_ | RestCourses], MyClasses, N, U) :-
	subseq(RestCourses, MyClasses, N, U).
subseq([Class | RestCourses], [Class | RestMyClasses], N, U) :-
	maxCourseLoad(Y),
	N < Y,
	unitsSum(Class, N, M),
	subseq(RestCourses, RestMyClasses, M, U).

unitsSum([[_, _, Units | _], _], N, M):-
	M is Units + N.

%Checks that no class has been added multiple times to a schedule.
noRepeatClasses(ClassList):-
	classNameList(ClassList, NameList),
    is_set(NameList).

% Get the title of every course in a schedule
classNameList([], []).
classNameList([[[H|_]|_]|Rest], [H | RNames]):-
	classNameList(Rest, RNames).

%generates list of list of class times. and passes to classConflict
noTimeConflicts(MySchedule):-
	classStartAndEnd(MySchedule, [FirstClassTL | RestClassTL]),
	classConflict(FirstClassTL, RestClassTL).

%returns a list of all class times in a given possible schedule which can then be checked for conflicts.
classStartAndEnd([], []).
classStartAndEnd([[[_, _, _, SDate, EDate, _, Times], _] | Rest ], [[SDate, EDate, Times] | RTimes]):-
	classStartAndEnd(Rest, RTimes).

%gets every 2 classes' lists of times and passes them to singleClassConflict or dateConflict to check if they conflict.
classConflict(_, []).
classConflict([S1, E1, Class1], [[ S2, E2, Class2]| Rest]):-
	singleClassConflict(Class1, Class2),
	classConflict([S1, E1, Class1], Rest),
	classConflict([S2, E2, Class2], Rest), !.
classConflict([S1, E1, Class1], [[ S2, E2, Class2]| Rest]):-
	dateConflict(S1, E2),
	classConflict([S1, E1, Class1] , Rest),
	classConflict([S2, E2, Class2], Rest), !.
classConflict([S1, E1, Class1], [[S2, E2, Class2]| Rest]):-
	dateConflict(S2, E1),
	classConflict([S1, E1, Class1], Rest),
	classConflict([S2, E2, Class2], Rest).

%Checks if the end month of one class is the start month of another class. (They are opposite half semester classes.)
dateConflict([M1 | _], [M2 | _]):-
	M1 = M2.

%passes each time block for class 1 and all of class 2's time blocks to singleTimeSlot
singleClassConflict([], _).
singleClassConflict([C1T1 | RestC1], C2):-
	singleTimeSlot(C1T1, C2),
	singleClassConflict(RestC1, C2).

%passes each time block for class 2 along with a specific time block of class 1 to singleTimeSlot
singleTimeSlot(_, []).
singleTimeSlot(C1T1, [C2T1 | RestC2]):-
	singleTimeConflict(C1T1, C2T1),
	singleTimeSlot(C1T1, RestC2).


% Checks if 2 class times overlap
singleTimeConflict([D1 | _], [D2 | _]):-
	D1 \= D2.
singleTimeConflict([D1, S1, E1 | _], [D2, S2 | _]):-
	D1 = D2,
	S1 < S2, 
	E1 < S2.
singleTimeConflict([D1, S1 | _], [D2, S2, E2 | _]):-
	D1 = D2,
	S2< S1, 
	E2 < S1.

%Generates a singal schedules value
scheduleVal([], CurVal, CurVal).
scheduleVal([ [_, CVal] | MySchedule], CurVal, Value):-
	NValue is CVal + CurVal,
	scheduleVal(MySchedule, NValue, Value).

